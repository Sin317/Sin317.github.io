<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming in Rust | Khushi's Blog</title>
<meta name=keywords content="rust,datastructure"><meta name=description content="Data structures and ownership in RUST"><meta name=author content="Khushi"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://sin317.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sin317.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sin317.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sin317.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sin317.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sin317.github.io/posts/rust_intro/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Programming in Rust"><meta property="og:description" content="Data structures and ownership in RUST"><meta property="og:type" content="article"><meta property="og:url" content="https://sin317.github.io/posts/rust_intro/"><meta property="og:image" content="https://sin317.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-04T22:28:42-08:00"><meta property="article:modified_time" content="2025-01-04T22:28:42-08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sin317.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Programming in Rust"><meta name=twitter:description content="Data structures and ownership in RUST"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sin317.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming in Rust","item":"https://sin317.github.io/posts/rust_intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Programming in Rust","name":"Programming in Rust","description":"Data structures and ownership in RUST","keywords":["rust","datastructure"],"articleBody":"Understanding Rust Data Structures and Ownership Rust is a modern systems programming language that guarantees memory safety and concurrency without a garbage collector. At the heart of Rust’s design are ownership, borrowing, and lifetimes, which play a crucial role in how data structures are implemented and used. This blog explores Rust’s ownership model and common data structures with illustrative code examples.\nCommon Data Structures Vectors Vectors are dynamic arrays that grow and shrink in size. They’re owned collections, meaning their data is managed by the vector itself.\nExample: Using Vectors\nfn main() { let mut v = vec![1, 2, 3]; v.push(4); // Add an element println!(\"{:?}\", v); // Output: [1, 2, 3, 4] // Iterating over a vector for i in \u0026v { println!(\"{}\", i); } } HashMap Key Value store\nExample:\nuse std::collections::HashMap; fn main() { let mut scores = HashMap::new(); scores.insert(\"Alice\", 50); scores.insert(\"Bob\", 30); // Accessing values if let Some(score) = scores.get(\"Alice\") { println!(\"Alice's score: {}\", score); } // Iterating over the HashMap for (key, value) in \u0026scores { println!(\"{}: {}\", key, value); } } The Ownership Model in Rust Rust’s ownership model has three core rules:\nEach value in Rust has a variable called its owner. A value can have only one owner at a time. When the owner goes out of scope, the value is dropped. Example: Ownership and Scope fn main() { let s1 = String::from(\"hello\"); // s1 owns the String let s2 = s1; // Ownership of the String is moved to s2 // println!(\"{}\", s1); // Error: s1 is no longer valid println!(\"{}\", s2); // Output: hello } Borrowing You can have multiple immutable borrows or one mutable borrow, but not both at the same time. A borrow (immutable or mutable) must always be valid for its scope. By enforcing these rules, Rust prevents data races and ensures memory safety at compile time. 1. Mutable Borrow: A mutable borrow gives you the ability to modify the borrowed value, but it enforces exclusivity. Only one mutable borrow is allowed at a time, and no immutable borrows can exist simultaneously.\nExample:\nfn main() { let mut v = vec![1, 2, 3]; { let v_mut = \u0026mut v; // Mutable borrow v_mut.push(4); // Modifying the vector } // v_mut goes out of scope here println!(\"{:?}\", v); // Output: [1, 2, 3, 4] } 2. Reference (Immutable Borrow): An immutable borrow means you can read the value without taking ownership, but you cannot modify it. Multiple immutable borrows are allowed simultaneously because they don’t change the data.\nExample:\nfn main() { let s = String::from(\"hello\"); let r1 = \u0026s; // Immutable borrow let r2 = \u0026s; // Another immutable borrow println!(\"{} and {}\", r1, r2); // Both r1 and r2 can be used } Borrow conflict example: fn main() { let mut s = String::from(\"hello\"); let r1 = \u0026s; // Immutable borrow // let r2 = \u0026mut s; // Error: Cannot have a mutable borrow while immutable borrows exist println!(\"{}\", r1); } ","wordCount":"495","inLanguage":"en","image":"https://sin317.github.io/%3Cimage%20path/url%3E","datePublished":"2025-01-04T22:28:42-08:00","dateModified":"2025-01-04T22:28:42-08:00","author":{"@type":"Person","name":"Khushi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sin317.github.io/posts/rust_intro/"},"publisher":{"@type":"Organization","name":"Khushi's Blog","logo":{"@type":"ImageObject","url":"https://sin317.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sin317.github.io/ accesskey=h title="Khushi's Blog (Alt + H)">Khushi's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sin317.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://sin317.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://sin317.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://sin317.github.io/portfolio/ title=Me><span>Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sin317.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sin317.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Programming in Rust</h1><div class=post-description>Data structures and ownership in RUST</div><div class=post-meta><span title='2025-01-04 22:28:42 -0800 PST'>January 4, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;495 words&nbsp;·&nbsp;Khushi&nbsp;|&nbsp;<a href=https://github.com/sin317.github.io/content/posts/rust_intro.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#understanding-rust-data-structures-and-ownership aria-label="Understanding Rust Data Structures and Ownership">Understanding Rust Data Structures and Ownership</a><ul><li><a href=#common-data-structures aria-label="Common Data Structures">Common Data Structures</a><ul><li><a href=#vectors aria-label=Vectors>Vectors</a></li><li><a href=#hashmap aria-label=HashMap>HashMap</a></li></ul></li><li><a href=#the-ownership-model-in-rust aria-label="The Ownership Model in Rust">The Ownership Model in Rust</a><ul><li><a href=#example-ownership-and-scope aria-label="Example: Ownership and Scope">Example: Ownership and Scope</a></li><li><a href=#borrowing aria-label=Borrowing>Borrowing</a><ul><li><a href=#1-mutable-borrow aria-label="1. Mutable Borrow:">1. Mutable Borrow:</a></li><li><a href=#2-reference-immutable-borrow aria-label="2. Reference (Immutable Borrow):">2. Reference (Immutable Borrow):</a></li><li><a href=#borrow-conflict-example aria-label="Borrow conflict example:">Borrow conflict example:</a></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=understanding-rust-data-structures-and-ownership>Understanding Rust Data Structures and Ownership<a hidden class=anchor aria-hidden=true href=#understanding-rust-data-structures-and-ownership>#</a></h1><p>Rust is a modern systems programming language that guarantees memory safety and concurrency without a garbage collector. At the heart of Rust&rsquo;s design are <strong>ownership</strong>, <strong>borrowing</strong>, and <strong>lifetimes</strong>, which play a crucial role in how data structures are implemented and used. This blog explores Rust&rsquo;s ownership model and common data structures with illustrative code examples.</p><hr><h2 id=common-data-structures>Common Data Structures<a hidden class=anchor aria-hidden=true href=#common-data-structures>#</a></h2><h3 id=vectors>Vectors<a hidden class=anchor aria-hidden=true href=#vectors>#</a></h3><p>Vectors are dynamic arrays that grow and shrink in size. They&rsquo;re owned collections, meaning their data is managed by the vector itself.</p><p>Example: Using Vectors</p><pre tabindex=0><code>fn main() {
    let mut v = vec![1, 2, 3];
    v.push(4); // Add an element
    println!(&#34;{:?}&#34;, v); // Output: [1, 2, 3, 4]

    // Iterating over a vector
    for i in &amp;v {
        println!(&#34;{}&#34;, i);
    }
}
</code></pre><h3 id=hashmap>HashMap<a hidden class=anchor aria-hidden=true href=#hashmap>#</a></h3><p>Key Value store</p><p>Example:</p><pre tabindex=0><code>use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(&#34;Alice&#34;, 50);
    scores.insert(&#34;Bob&#34;, 30);

    // Accessing values
    if let Some(score) = scores.get(&#34;Alice&#34;) {
        println!(&#34;Alice&#39;s score: {}&#34;, score);
    }

    // Iterating over the HashMap
    for (key, value) in &amp;scores {
        println!(&#34;{}: {}&#34;, key, value);
    }
}
</code></pre><h2 id=the-ownership-model-in-rust>The Ownership Model in Rust<a hidden class=anchor aria-hidden=true href=#the-ownership-model-in-rust>#</a></h2><p>Rust&rsquo;s ownership model has three core rules:</p><ol><li>Each value in Rust has a variable called its <strong>owner</strong>.</li><li>A value can have only one owner at a time.</li><li>When the owner goes out of scope, the value is dropped.</li></ol><h3 id=example-ownership-and-scope>Example: Ownership and Scope<a hidden class=anchor aria-hidden=true href=#example-ownership-and-scope>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// s1 owns the String
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s1</span><span class=p>;</span><span class=w> </span><span class=c1>// Ownership of the String is moved to s2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// println!(&#34;{}&#34;, s1); // Error: s1 is no longer valid
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s2</span><span class=p>);</span><span class=w> </span><span class=c1>// Output: hello
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=borrowing>Borrowing<a hidden class=anchor aria-hidden=true href=#borrowing>#</a></h3><ul><li>You can have multiple immutable borrows or one mutable borrow, but not both at the same time.</li><li>A borrow (immutable or mutable) must always be valid for its scope.</li><li>By enforcing these rules, Rust prevents data races and ensures memory safety at compile time.</li></ul><h4 id=1-mutable-borrow>1. Mutable Borrow:<a hidden class=anchor aria-hidden=true href=#1-mutable-borrow>#</a></h4><p>A mutable borrow gives you the ability to modify the borrowed value, but it enforces exclusivity.
Only one mutable borrow is allowed at a time, and no immutable borrows can exist simultaneously.</p><p>Example:</p><pre tabindex=0><code>fn main() {
    let mut v = vec![1, 2, 3];
    {
        let v_mut = &amp;mut v; // Mutable borrow
        v_mut.push(4); // Modifying the vector
    } // v_mut goes out of scope here

    println!(&#34;{:?}&#34;, v); // Output: [1, 2, 3, 4]
}
</code></pre><h4 id=2-reference-immutable-borrow>2. Reference (Immutable Borrow):<a hidden class=anchor aria-hidden=true href=#2-reference-immutable-borrow>#</a></h4><p>An immutable borrow means you can read the value without taking ownership, but you cannot modify it.
Multiple immutable borrows are allowed simultaneously because they don&rsquo;t change the data.</p><p>Example:</p><pre tabindex=0><code>fn main() {
    let s = String::from(&#34;hello&#34;);

    let r1 = &amp;s; // Immutable borrow
    let r2 = &amp;s; // Another immutable borrow

    println!(&#34;{} and {}&#34;, r1, r2); // Both r1 and r2 can be used
}
</code></pre><h4 id=borrow-conflict-example>Borrow conflict example:<a hidden class=anchor aria-hidden=true href=#borrow-conflict-example>#</a></h4><pre tabindex=0><code>fn main() {
    let mut s = String::from(&#34;hello&#34;);

    let r1 = &amp;s; // Immutable borrow
    // let r2 = &amp;mut s; // Error: Cannot have a mutable borrow while immutable borrows exist

    println!(&#34;{}&#34;, r1);
}
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://sin317.github.io/tags/rust/>Rust</a></li><li><a href=https://sin317.github.io/tags/datastructure/>Datastructure</a></li></ul><nav class=paginav><a class=prev href=https://sin317.github.io/posts/babycorn_palya/><span class=title>« Prev</span><br><span>Babycorn Palya</span>
</a><a class=next href=https://sin317.github.io/posts/plantaincake/><span class=title>Next »</span><br><span>Plantaincake</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://sin317.github.io/>Khushi's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>